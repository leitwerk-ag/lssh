#! /usr/bin/env python3

import argparse, crontab, os, pathlib, pkgutil, shutil, subprocess, sys

# Check commandline
parser = argparse.ArgumentParser(prog='debian-systemwide-install')

parser.add_argument('-p', '--install-packages', dest='packages', action='store_true', help='Automatically install needed packages via apt and python modules via pip')
parser.add_argument('clone_url', help='Git clone url to load the ssh configuration')

parsed_args = parser.parse_args()

repo_url = parsed_args.clone_url

# Run the installation

# Check for packages
if not parsed_args.packages:
    missing_apt_packages = []
    if shutil.which("sudo") is None:
        missing_apt_packages.append("sudo")
    if shutil.which("git") is None:
        missing_apt_packages.append("git")
    if shutil.which("pip3") is None:
        missing_apt_packages.append("python3-pip")
    if pkgutil.find_loader('xdg') is None:
        missing_apt_packages.append("python3-xdg")
    py_cui_available = pkgutil.find_loader('py_cui') is not None
    if len(missing_apt_packages) > 1:
        print("The following debian packages are missing: " + " ".join(missing_apt_packages), file=sys.stderr)
    elif len(missing_apt_packages) == 1:
        print("The debian package `" + missing_apt_packages[0] + "' is missing.", file=sys.stderr)
    if not py_cui_available:
        print("The python module `py-cui' is missing.", file=sys.stderr)
    if len(missing_apt_packages) > 0 or not py_cui_available:
        print("You may run this installer with -p (or --install-packages) to install dependencies automatically.", file=sys.stderr)
        print("Note: The uninstaller will not uninstall these dependencies", file=sys.stderr)
        sys.exit(1)

# Copy source files
try:
    base_dir = pathlib.Path(os.path.realpath(__file__)).parent.parent
    src = base_dir / "lssh"
    dst = pathlib.Path("/usr/local/lib/lssh")
    print("Copying source files to " + str(dst) + " ...")
    os.makedirs(dst, exist_ok=True)
    src_files = {f for f in os.listdir(src) if f.endswith(".py")}
    dst_files = {f for f in os.listdir(dst) if f.endswith(".py")}
    # Copy from source to destination
    for filename in src_files:
        shutil.copy(src / filename, dst / filename)
    # Remove files that have been removed in source dir
    for filename in (dst_files - src_files):
        os.remove(dst / filename)
except PermissionError as e:
    print("Got a PermissionError: " + str(e), file=sys.stderr)
    print("Note, that this system-wide installer needs root permissions.")
    sys.exit(1)

if parsed_args.packages:
    # Install needed debian packages
    print("Installing sudo, git, python3-pip and python3-xdg ...")
    subprocess.run(["apt", "install", "-y", "sudo", "git", "python3-pip", "python3-xdg"]).check_returncode()

    # Install the py_cui module
    print("Installing the py_cui python module ...")
    subprocess.run(["pip3", "install", "py_cui"])

# Clone the repository
lssh_home = pathlib.Path("/var/local/lssh")
repo_path = lssh_home / "host_repo"
if not os.path.isdir(repo_path / ".git"):
    print("Cloning repository into " + str(repo_path) + " ...")
    os.makedirs(repo_path, mode=0o700, exist_ok=True)
    ret = subprocess.run(["git", "clone", repo_url, str(repo_path)]).returncode
    git_clone_success = ret == 0
else:
    print("Repository in " + str(repo_path) + " already exists.")
    git_clone_success = True

# Create the directory for validated hosts
validated = lssh_home / "hosts"
print("Creating directory for validated hosts in " + str(validated) + " ...")
os.makedirs(validated, exist_ok=True)

# Create a pull wrapper-script
wrapper_file = "/var/local/lssh/pull.sh"
print("Creating pull wrapper " + str(wrapper_file) + " ...")
with open(wrapper_file, "w") as f:
    f.write("""#! /bin/bash -e

cd "$(dirname "$0")"/host_repo
git pull
/usr/local/bin/lssh --load-from .
""")
os.chmod(wrapper_file, 0o755)

# Create a sudo rule for pull
sudo_rule_file = "/etc/sudoers.d/lssh"
print("Creating sudo rule in " + sudo_rule_file + " ...")
with open(sudo_rule_file, "w") as f:
    f.write("""# Allow anyone to execute "git pull" as user lssh
ALL ALL = (root) NOPASSWD:/var/local/lssh/pull.sh
""")
os.chmod(sudo_rule_file, 0o440)

# Create the lssh executable file
lssh_file = "/usr/local/bin/lssh"
print("Creating lssh executable in " + str(lssh_file) + " ...")
with open(lssh_file, "w") as f:
    f.write("""#! /usr/bin/env python3

import sys

hosts_dir = "/var/local/lssh/hosts"

def update_hosts():
    import subprocess
    subprocess.run(["sudo", "/var/local/lssh/pull.sh"])

sys.path.append("/usr/local/lib")

from lssh import main
main.main(hosts_dir, update_hosts)
""")
os.chmod(lssh_file, 0o755)

# Setup tab-completion
complete_file = "/etc/bash_completion.d/lssh_completion"
print("Writing bash completion instructions to " + complete_file + " ...")
with open(complete_file, "w") as f:
    f.write("complete -o filenames -C 'lssh __complete__' lssh\n")

# Crontab entry
print("Creating a crontab entry to update the hostlist regularly ...")
crontab.add_pull_entry()

if git_clone_success:
    print("Loading initial hostlist ...")
    subprocess.run(["lssh", "--load-from", str(repo_path)]).check_returncode()
else:
    print("")
    print("Warning:")
    print("  Your git repository could not be cloned successfully. (See above)")
    print("  Please ensure you have the needed permissions, then clone")
    print("  the repository to the path " + str(repo_path) + " or run")
    print("  this installer again.")
    sys.exit(1)
